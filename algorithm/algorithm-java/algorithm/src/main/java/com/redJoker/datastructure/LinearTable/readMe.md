## 线性表:
    线性表指数据之间的关系是1对1的。存储方式有两种: 顺序存储以及链式存储。
### 顺序存储:
    其实就是数组,他的特点是地址连续,大小固定。
    新增 / 删除:
        最好的情况:在数组末尾新增数据, 时间复杂度是O(1)
        最坏的情况:在数组开头新增数据, 所有的数据都要向后移动一位,时间复杂度是O(n)
    查看:
        获取某一位数据, 通过index(数组下标)取获取, 时间复杂度是O(1)
        获取某个值, 需要遍历数组,时间复杂度是O(n)
        
### 链式存储:
    新增:
        在链表中插入数据, 需要修改一个节点的指针域即可,比如在5和7之间插入6, 第一步先将要插入的
    6指向5,然后把7的指向由5变到6即可。 时间复杂度是O(1)
    删除:
        要删除6,首先直接将7的节点指向从6变到5即可,然后删除6节点。时间复杂度也是O(1)
    查询:
        不支持通过index来查询,所以必须要遍历,时间复杂度是O(n)
        
    单链表 
        常规实现(CRUD) 
        单链表的环检测: 使用快慢指针,同时从头节点开始,如果两个指针相遇,说明链表打结
        单链表实现翻转:
        有序链表的合并:
        详见 com.redJoker.datastructure.LinearTable.SingleList
        
    双向链表 双向链表是在单链表的基础上实现的, 需要在原有的基础上加prev指针即可。
        新增: 
            头部新增:  原来是(head节点 -> A -> B...) 现在需要(head节点 -> NEW -> A -> B...)
                1. NEW节点next指向A节点
                2. A节点的的pre由原来的指向NULL变为指向NEW节点
                3. 然后把head节点的next由指向A变为指向NEW
                4. 将NEW节点的pre指向NULL
            尾部新增: 原来是(head节点 -> A -> B)  现在需要(head节点 -> A -> B -> NEW)
                1. B节点的next由之前的NULL指向NEW
                2. NEW节点的pre指向B节点
            任意部位新增: 原来是(head节点 -> A -> B...) 现在需要(head节点 -> A -> NEW -> B)
                1. NEW节点的next指向B节点
                2. B节点的pre指向由A指向变为指向NEW节点
                3. NEW节点的pre指向A节点
                4. A节点的next指向由B到NEW
        删除: 
            头节点删除: 原来是(head -> A -> B ...)  现在需要(head -> B ...)
                1. head节点的next指向由原来的A指向指向B
                2. B节点的pre指向由原来的A指向head 
            尾节点删除: 原来是(head -> A -> B -> C)  现在需要(head -> A -> B)
                1. B节点的next指向由原来的指向B变为指向NULL
                2. B节点的pre指向 由原来的A指向变为NULL
            删除任意节点: 原来是(head -> A -> B -> C)  现在需要(head -> A -> C)
                
    
    
        
     
        
        
    
    
    
    
   